// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'

Shader "azure[Sky]/azure[Sky]_PreRenderedClouds"
{
//	Properties
//	{
//		
//	}
	SubShader 
	{
	    Tags { "Queue"="Background" "RenderType"="Background" "PreviewType"="Skybox" "IgnoreProjector"="True" }
	    Cull Back     // Render side
		Fog{Mode Off} // Don't use fog
    	ZWrite Off    // Don't draw to bepth buffer
    	Pass 
    	{
			CGPROGRAM
			#pragma target 3.0
			#pragma vertex vert
			#pragma fragment frag
			#pragma multi_compile HDR_ON HDR_OFF

			uniform float3 _Br;
			uniform float3 _Br2;
			uniform float3 _Bm;
			uniform float3 _Brm;    //Br + Bm
			uniform float3 _mieG;
			uniform float  _SunIntensity;
			uniform float  _MoonIntensity;
			uniform float  _Kr;
			uniform float  _Km;
			uniform float  _Altitude;
			uniform float  _pi316;
			uniform float  _pi14;
			uniform float  _pi;

			uniform float  _Exposure;
			uniform float  _SkyLuminance;
			uniform float  _SkyDarkness;
			uniform float  _SunsetPower;
			uniform float  _SunDiskSize;
		    uniform float  _SunDiskIntensity;
		    uniform float  _SunDiskPropagation;
		    uniform float  _MoonSize;
		    uniform float  _StarsIntensity;
			uniform float  _StarsExtinction;
			uniform float  _MilkyWayIntensity;
			uniform float  _MilkyWayPower;

//			uniform float4 _SunColor;
			uniform float4 _SunsetColor;
			uniform float4 _MoonColor;
			uniform float4 _MoonBrightColor;
			uniform float  _MoonExtinction;
			uniform int    _MoonEclipseShadow;
			uniform float  _Umbra;
			uniform float  _UmbraSize;
			uniform float  _Penumbra;
			uniform float  _PenumbraSize;

			uniform sampler2D    _MoonSampler;
			uniform samplerCUBE  _StarField;
			uniform samplerCUBE  _StarNoise;
			uniform samplerCUBE  _MilkyWay;

			uniform sampler2D    _Cloud1;
			uniform sampler2D    _Cloud2;
			uniform float        _CloudLerp;
			uniform float        _Longitude;
			uniform float        _AlphaSaturation;
			uniform float        _CloudAltitude;

			uniform float     _ColorCorrection;
			
			uniform float3    _SunDir;
			uniform float3    _MoonDir;
			uniform float4x4  _SunMatrix;
			uniform float4x4  _MoonMatrix;
			uniform float4x4  _NoiseMatrix;
			uniform float4x4  _MilkyWayMatrix;

			uniform float4    _GroundCloseColor;
			uniform float4    _GroundFarColor;
			uniform float     _FarColorDistance;
			uniform float     _FarColorIntensity;

			uniform float4    _PenumbraColor;
			
			struct appdata{
			    float4 vertex   : POSITION;
			};

			struct v2f 
			{
    			float4 Position     : SV_POSITION;
    			float3 WorldPos     : TEXCOORD0;
    			float4 Fade         : TEXCOORD1; // sunFade,  mix,  fadeOtherSideMoon.
    			float3 moonPos      : TEXCOORD2;
    			float3 sunPos       : TEXCOORD3;
    			float2 nightCompute : TEXCOORD4;
    			float3 noiseRot     : TEXCOORD5;
//    			float3 milkyWayPos  : TEXCOORD6;
			};

			v2f vert(appdata v)
			{
    			v2f o;
    			UNITY_INITIALIZE_OUTPUT(v2f, o);
    			
    			o.Position = UnityObjectToClipPos(v.vertex);
    			o.WorldPos = normalize(mul((float4x4)unity_ObjectToWorld, v.vertex)).xyz;

    			float3 viewDir = normalize(o.WorldPos+float3(0.0,_Altitude,0.0));
    			
    			o.Fade.x = saturate( _SunDir.y + 0.25 );                             		 	     		// Fade the sun ("daysky") when cross the horizon.
			    o.Fade.y = saturate(clamp(1.0 - _SunDir.y, 0.0, 0.5));                          	 		// Mix sunset"(fex)" with daysky"(1-fex)".
			    o.Fade.z = saturate(dot(-_MoonMatrix[2].xyz,o.WorldPos));                                   // Fade  the other side moon generated by the moonMatrix
			    o.Fade.w = pow(max(0.0,viewDir.y - 0.025),_MoonExtinction);									// Fade the moon when cross the horizon.

			    //////////
			    //MATRIX//
    			o.noiseRot = mul((float3x3)_NoiseMatrix,v.vertex.xyz); 							 			// Rotate noise texture to apply star scintillation
    			o.sunPos   = mul((float3x3)_SunMatrix,v.vertex.xyz);
    			o.moonPos  = mul((float3x3)_MoonMatrix,v.vertex.xyz);
    			o.moonPos.x *= -1; //Invert x scale
    			// For the rotation of the moon
//    			o.moonPos.x = -dot(_MoonMatrix[0].xyz,v.vertex.xyz); // x scale inverted
//    			o.moonPos.y =  dot(_MoonMatrix[1].xyz,v.vertex.xyz);
//    			o.moonPos.z =  dot(_MoonMatrix[2].xyz,v.vertex.xyz);

//    			o.nightCompute.x = pow(max(0.0,o.WorldPos.y),_StarsExtinction);
    			o.nightCompute.x = pow(max(0.0,viewDir.y),_StarsExtinction);// Stars extinction from zenith to the horizon.
				o.nightCompute.y = (-_SunDir.y + _Altitude) * ((_MoonDir.y+0.25) + _Altitude);//Fade the moon Bright when is day or cross the horizon

    			return o;
			}
			
			float4 frag(v2f IN) : SV_Target
			{
			   //-------------------------------------------------------------------------------------------------------
			   //-------------------------------------------Directions--------------------------------------------------
               float3 viewDir     = normalize(IN.WorldPos);
			   float sunCosTheta  = dot( viewDir, _SunDir );
			   viewDir            = normalize(IN.WorldPos+float3(0.0,_Altitude,0.0)); // Change the horizon altitude. "(0.1=HorAlt)"
			   float3 cloudViewDir= normalize(IN.WorldPos+float3(0.0,_CloudAltitude,0.0));

			   //-------------------------------------------------------------------------------------------------------
			   //-------------------------------------------Extinction--------------------------------------------------
			   float  zenith = acos(saturate(viewDir.y));
			   float  z      = (cos(zenith) + 0.15 * pow(93.885 - ((zenith * 180.0) / _pi), -1.253));
			   float  SR     = _Kr  / z;
			   float  SM     = _Km  / z;
			   float3 fex    = exp(-(_Br*SR  + _Bm*SM));  // Original fex calculation.
			   float3 fex2   = exp(-(_Br2*SR + _Bm*SM)); // Fex calculation with rayleigh coefficient == 3. For the sunset.
			   //-------------------------------------------------------------------------------------------------------
			   //-------------------------------------------Cloud Mask--------------------------------------------------
			   float2 uv = float2(-atan2(cloudViewDir.z, cloudViewDir.x), -acos(cloudViewDir.y)) / float2(2.0*_pi, _pi);
				      uv = (uv - float2(_Longitude, 0)) + float2(0.35, 0);
			   float4 C1 = tex2D(_Cloud1, uv);
			   float4 C2 = tex2D(_Cloud2, uv);
			   float4 tex       = lerp(C1, C2, _CloudLerp);
			   float  cloudMask = (1-pow( tex.a, _AlphaSaturation));

			   //-------------------------------------------------------------------------------------------------------
			   //-----------------------------------------Sun Scattering------------------------------------------------
			   //float  rayPhase = 1.0 + pow(cosTheta,2.0);                          // Preetham rayleigh phase function.
			   float  rayPhase = 2.0 + 0.5 * pow(sunCosTheta,2.0);                   // Rayleigh phase function based on the Nielsen's paper.
			   float  miePhase = _mieG.x / pow(_mieG.y - _mieG.z * sunCosTheta,1.5); // The Henyey-Greenstein phase function.
			    
			   float3 BrTheta  = _pi316 * _Br * rayPhase;
			   float3 BmTheta  = _pi14  * _Bm * miePhase;
			   float3 BrmTheta = (BrTheta + BmTheta * 2.0) / (_Brm * 0.75);        // Brm is "Br+Bm", and the sum is already made in the Control Script.

			   float3 inScatter = BrmTheta * _SunIntensity * (1.0 - fex);
			   inScatter *= saturate((lerp( _SunsetPower , pow(2000.0 * BrmTheta * fex2,0.5),IN.Fade.y) * 0.05));
			   inScatter *= _SkyLuminance * _SunsetColor.rgb;
			   inScatter *= pow((1-fex),_SkyDarkness);
			   inScatter *= IN.Fade.x; // Sun fade in the horizon.
			   
			   ////////////////
			   // Solar Disk //
			   float3 sunDisk  = min(2, pow((1-sunCosTheta) * _SunDiskSize , _SunDiskPropagation )) * fex2 * _SunDiskIntensity;

			   /////////////////
			   //Lunar Eclipse//
			   float  Umbra    = 1-min(_Umbra, pow((1-(-sunCosTheta)) * _SunDiskSize , -_UmbraSize )) ;
			   float  Penumbra = min(1, pow((1-(-sunCosTheta)) * _SunDiskSize , -_PenumbraSize ));
			   float3 LunarEclipse = saturate(float3(Umbra, Umbra, Umbra) * (lerp(float3(1,1,1), _PenumbraColor,Penumbra * _Penumbra)));


			   //-------------------------------------------------------------------------------------------------------
			   //--------------------------------------------Night Sky--------------------------------------------------
			   float  nightIntensity = 0.25;
			   float3 nightSky   = saturate((pow( 1-fex2, 2.0) * nightIntensity) * (1-IN.Fade.x)); // Defaut night sky color
			   		  nightSky  *= saturate(pow((1-fex2),_SkyDarkness));
			          nightSky  *= _SkyLuminance;

			   float3 groundColor = lerp(_GroundCloseColor, _GroundFarColor, (viewDir.y + _FarColorDistance));
			          nightSky    = saturate(lerp(groundColor, nightSky, saturate(dot(viewDir.y + _FarColorIntensity, float3(0,1,0)))) * (1-fex));
//			          nightSky    = saturate(lerp(groundColor, nightSky, viewDir.y + _LerpNightSkyDistance) * (1-fex));

			   ////////////////
			   //    Moon    //
			   float4 moonSampler = tex2D(_MoonSampler, IN.moonPos.xy * _MoonSize + float2(0.5,0.5)) * IN.Fade.z * lerp(1, float4(LunarEclipse,1),_MoonEclipseShadow);
			   float4 moonColor   = ( moonSampler ) * IN.Fade.w * cloudMask;
			   float  moonMask    = (1 - moonSampler.a); // To hide the stars that are behind the moon
			   float3 moonBright  = saturate( (_MoonBrightColor.rgb * _MoonIntensity) * pow(dot(viewDir, _MoonDir),5.0)  * IN.nightCompute.y ) * (1-(moonColor.b)) * 3 * IN.Fade.z;

			   ////////////////
			   //    Stars   //
			   float  fadeStar      = IN.nightCompute.x * _StarsIntensity * (1.0 - moonBright * 10.0); // When the stars will emerge and fade.
			   float  scintillation = texCUBE(_StarNoise, IN.noiseRot.xyz) * 2.0;
			   float3 stars         = saturate(texCUBE(_StarField, IN.sunPos.xyz) * fadeStar * moonMask) * scintillation;
			   ////////////////
			   //  Milkyway  //
			   float3 milkyWay      = saturate(pow(texCUBE(_MilkyWay, mul((float3x3)_MilkyWayMatrix, IN.sunPos.xyz)), _MilkyWayPower) * fadeStar * moonMask) * _MilkyWayIntensity;

			   nightSky += (stars + milkyWay)* cloudMask + moonBright;

			   //*******************************************************************************************************
			   //-------------------------------------------------------------------------------------------------------
			   //------------------------------------------Sky finalization---------------------------------------------
			   inScatter += sunDisk;
			   float3 finalSky = (inScatter + nightSky);
			   
		   	   ////////////////
			   // tonemaping //
			   #ifndef HDR_ON
			   finalSky = saturate( 1.0 - exp( -_Exposure * finalSky ));
			   #endif

			   finalSky *= lerp(1, moonColor, moonColor.b);
			   finalSky += moonColor.rgb;

			   //////////////////////
			   // Color Correction //
			   finalSky = pow(finalSky,_ColorCorrection);
			   return float4(finalSky,1.0);
			}
			ENDCG
    	}


    	/////////////////////////
    	/////////CLOUDS//////////
    	Pass 
    	{
    		Blend SrcAlpha OneMinusSrcAlpha
    		
			CGPROGRAM
			#pragma target 3.0
			#pragma vertex vert
			#pragma fragment frag
//			#pragma multi_compile HDR_ON HDR_OFF
			
			uniform sampler2D    _Cloud1;
			uniform sampler2D    _Cloud2;
			uniform float        _CloudLerp;
			
			uniform float3    _SunDir;
			uniform float3    _MoonDir;
			uniform float     _CloudAltitude;
			
			uniform float     _SkyLuminance;
			uniform float     _NightIntensity;

			uniform float     _pi;
			
			uniform float     _CloudExtinction;
			uniform float     _AlphaSaturation;
			uniform float     _CloudDensity;
			uniform float4    _EdgeColor;
			uniform float4    _DarkColor;
			
			uniform float     _MoonIntensity;
			uniform float4    _MoonBrightColor;
			uniform float     _MoonBrightIntensity;
			uniform float     _MoonBrightRange;
			uniform float4x4  _MoonMatrix;
			
			uniform float     _Longitude;
			uniform int       _Rise_or_Down;
			
			uniform float     _ColorCorrection;
			
			
			struct appdata{
			    float4 vertex   : POSITION;
			};

			struct v2f 
			{
    			float4 Position     : SV_POSITION;
    			float3 WorldPos     : TEXCOORD0;
    			float3 Fade         : TEXCOORD1; // sunFade,  mix.
			};

			v2f vert(appdata v)
			{
    			v2f o;
    			UNITY_INITIALIZE_OUTPUT(v2f, o);
    			
    			o.Position = UnityObjectToClipPos(v.vertex);
    			o.WorldPos = normalize(mul(unity_ObjectToWorld, v.vertex).xyz);
    			
    			o.Fade.x = saturate( _SunDir.y+0.25 );                  // Fade the sun ("daysky") when cross the horizon.
			    o.Fade.y = saturate(clamp(1.0 - _SunDir.y,0.0,0.5));    // Mix sunset"(fex)" with daysky"(1-fex)".
			    o.Fade.z = saturate(dot(-_MoonMatrix[2].xyz,o.WorldPos)) * (o.WorldPos.y + _CloudAltitude);

    			return o;
			}
			
			float4 frag(v2f IN) : SV_Target
			{
			    ////////////////
			    // Directions //
				float3 viewDir    = normalize(IN.WorldPos+float3(0.0,_CloudAltitude,0.0));
				//Longitude = dot(sunDir,float3(1,0,0));
				
				//////////////
				// Textures //
				float2 uv    = float2(-atan2(viewDir.z, viewDir.x), -acos(viewDir.y)) / float2(2.0*_pi, _pi);
				       uv = (uv - float2(_Longitude, 0)) + float2(0.35, 0);
				float4 C1 = tex2D(_Cloud1, uv);
			    float4 C2 = tex2D(_Cloud2, uv);
				float4 tex   = lerp(C1, C2, _CloudLerp);
				float  alpha = pow( tex.a, _AlphaSaturation) * saturate(IN.WorldPos.y * _CloudExtinction);
				
				///////////////
				// Day Cloud //
				float3 edgeColor = _EdgeColor;
				float  rise = tex.r;
				float  up   = tex.g;
				float  down = tex.b;
				
				float3 cloudLuminance = lerp(rise,down,_Rise_or_Down);
				       cloudLuminance = lerp(cloudLuminance,up,saturate(dot(_SunDir,float3(0,1,0))));
			           
			    float3 dayCloud = lerp(_DarkColor,_EdgeColor * clamp(1,1.25,_SkyLuminance),saturate(pow(cloudLuminance,_CloudDensity)));
//			    float3 noonCloud   = lerp(_noonDarkColor,  _EdgeColor * clamp(1,1.25,dayLuminance),saturate(pow(cloudLuminance,_NoonCloudDensity)));
//				float3 dayCloud    = lerp(sunsetCloud,noonCloud,sunDir.y + 0.25);
				
				/////////////////
				// Night Cloud //
				cloudLuminance = lerp(rise,down,1-_Rise_or_Down);
			    cloudLuminance = lerp(cloudLuminance,up,saturate(dot(_MoonDir,float3(0,1,0))));
				float3 moonLight   = saturate( (_MoonBrightColor.rgb * (_MoonIntensity * _MoonBrightIntensity)) * pow(dot(viewDir, _MoonDir),_MoonBrightRange)  * IN.Fade.z );// Moonlight.
				float3 nightCloud  = lerp(_DarkColor, _EdgeColor * lerp(1,1.25,0.142) * 0.25 + moonLight,saturate(pow(cloudLuminance,_CloudDensity)));
				
				//////////////////
				// Finalization //
				float3 finalCloud = lerp(nightCloud, dayCloud, saturate(dot(float3(0, _SunDir.y + 0.3, 0), float3(0,2.25,0))));
				
				//////////////////////
			    // Color Correction //
			    finalCloud = pow(finalCloud,_ColorCorrection);
				
            	return float4(finalCloud,saturate(alpha));
			}
			ENDCG
    	}
    }
}